#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Mar 23 12:57:01 2021

@author: harshittrehan
"""

'''
#import glob
#import os

#file = glob.glob("problem2matrices/gamma22.txt")

with open("problem2matrices/gamma22.txt", "r") as f:
    for i in range(0,100):
        size=0
        with open("fakeSamples/fake" + str(i) + ".txt", "w") as wf:
            for line in f:
                wf.write(line)
                size+=1
                if size >= 300:
                    size=0
                    break
'''

import glob
import numpy as np
import math
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.metrics import roc_curve, auc

opdict = {}

N = 22
M = 22
T = 300

pi = np.empty(N, dtype = np.float64)
A = np.empty(N*N, dtype = np.float64)
B = np.empty(N*M, dtype = np.float64)

test_obs_seq = np.empty(T, dtype = np.int32)
alpha = np.zeros([T,N], dtype = np.float64)
scaling = np.zeros(T, dtype = np.float64)

scores = []
labels = [1]*100
for i in range (0, 100):
    labels.append(0)
    
df = pd.DataFrame()

def opcodeMapping():
    global opdict
    
    opfreq = {}
    
    with open("obseq.txt", "r") as f:
        for line in f:
            line = line.strip()
            if line not in opfreq:
                opfreq[line] = 1
            else:
                opfreq[line] += 1
    
    tup = sorted(opfreq.items(), key=lambda x:x[1], reverse=True)

    for i in range(0, M-1):
        opdict[tup[i][0]] = i
    #print(opdict)
    
def loadModel():
    global pi
    global A
    global B
    global N
    global M
    
    pi = np.loadtxt("problem2Matrices/bestPi" + str(M) + ".txt", delimiter='\n')
    A = np.loadtxt("problem2Matrices/bestA" + str(M) + ".txt", delimiter='\n')
    B = np.loadtxt("problem2Matrices/bestB" + str(M) + ".txt", delimiter='\n')
    B=B.reshape((N,M))
    A=A.reshape((N,N))
    
    for i in range (0, N):
        for j in range (0, M):
            if B[i][j] < 1.0e-9:
                B[i][j] = 0
            if A[i][j] < 1.0e-9:
                A[i][j] = 0
                
def alphaPassTest():
    global N
    global M
    global T    
    global pi
    global A
    global B
    global test_obs_seq
    global alpha
    global scaling
    #print(T)
    scaling[0]=0
    for i in range(0, N):
        alpha[0][i] = pi[i]*B[i][test_obs_seq[0]]
        scaling[0] = scaling[0] + alpha[0][i]
    
    if scaling[0] == 0 or scaling[0]< 1.0e-300:
        scaling[0] = 1/1.0e-9
    else:
        scaling[0] = 1/scaling[0]
    
    for i in range(0, N):
        alpha[0][i] = scaling[0]*alpha[0][i]
    
    for t in range(1, T):
        scaling[t]=0
        for i in range(0, N):
            alpha[t][i]=0.0
            for j in range(0, N):
                alpha[t][i] = alpha[t][i]+alpha[t-1][j]*A[j][i]
            
            alpha[t][i] = alpha[t][i]*B[i][test_obs_seq[t]]
            scaling[t] = scaling[t] + alpha[t][i]
        
        if scaling[t] == 0 or scaling[t]< 1.0e-300:
            scaling[t] = 1/1.0e-9
        else:
            scaling[t] = 1/scaling[t]
        
        for i in range(0, N):
            alpha[t][i] = scaling[t] * alpha[t][i]
            
    probability = 0.0
    for t in range(0, T):
        probability += math.log(scaling[t], math.e)
    
    return -1*probability
    

def testRunner():
    global opdict
    global test_obs_seq
    global M
    global df
    global T
    global scores
    global labels
    
    winTest = sorted(glob.glob('wintest/*.txt'))
    fakeTest = sorted(glob.glob('fakeSamples/*.txt'))
    
    for file in winTest:
        i=0
        with open(file, "r") as f:
            for line in f:
                line = line.strip()
                if line in opdict:
                    test_obs_seq[i] = opdict[line]
                else:
                    test_obs_seq[i] = M-1
                i += 1
                if i >= T:
                    break
        
        prob = alphaPassTest()
        #print('Probability for: ', file, ' = ', alphaPassTest())
        
        scores.append(prob)

    for file in fakeTest:
        i=0
        with open(file, "r") as f:
            for line in f:
                line = line.strip()
                if int(line) >= 20:
                    test_obs_seq[i] = M-1
                else:
                    test_obs_seq[i] = line
                i += 1
                if i >= T:
                    break
        
        prob = alphaPassTest()
        #print('Probability for: ', file, ' = ', alphaPassTest())
        
        scores.append(prob)
        
    # df = pd.DataFrame(list(zip(scores, labels)), columns =['Score', 'Label'])
    # df['x1'] = df.index
    
    # plt.scatter(x=df.x1, y=df.Score, s=5, c=df.Label)
    # plt.title('M = '+ str(M))
    # plt.show()

def runner():
    global M
    global scores
    global labels
    
    for M in range(22, 23):
        opcodeMapping()
        loadModel()
        testRunner()
        roc_auc = dict()
        fpr, tpr, _ = roc_curve(labels, scores)
        roc_auc = auc(fpr, tpr)
        print('AUC for M = ', M, 'is: ', roc_auc)
        
        plt.figure()
        plt.plot(fpr, tpr, color='darkorange', label='ROC curve (area = %0.5f)' % roc_auc)
        plt.xlim([0.0, 1.0])
        plt.ylim([0.0, 1.05])
        plt.xlabel('False Positive Rate')
        plt.ylabel('True Positive Rate')
        plt.title('ROC for M = %d' % M)
        plt.legend(loc="lower right")
        plt.show()
        
        scores = []

runner()                    

